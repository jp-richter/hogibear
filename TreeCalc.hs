import Prelude hiding (negate) 
import Parser

{-
    Author          Jan Richter
    Date            27.02.2018
    Description     This module provides functions to transform expression trees
                    generated by the Parser class into Negation Normal Form, 
                    Conjunctive Normal Form and Disjunctive Normal Form. 
-}

{-
    Functions Intended For External Use
-}

toNNF :: MTree -> MTree 
toNNF = resolveNegation . resolveImplication . resolveEquivalence

-- assumes that argument is in negation normal form
toCNF :: MTree -> MTree 
toCNF n = if isCNF n then n; else toCNF $ distributiveOr n  

{-
    Tree Convencience Functions
-}

children :: MTree -> [MTree]
children n@(Leaf _)  = []
children (Node _ ns) = ns

hasOperator :: MTree -> Operator -> Bool
hasOperator (Node op _) op' = op == op' 
hasOperator _ _             = False

isLeaf :: MTree -> Bool 
isLeaf (Leaf _) = True 
isLeaf _        = False

splitAtOp :: [MTree] -> Operator -> ([MTree],[MTree]) 
splitAtOp [] _      = ([],[]) 
splitAtOp (n:ns) op = case n of 
    _ | hasOperator n op -> ([n], ns)
      | otherwise        -> (fst $ splitAtOp ns op
                            , n:(snd $ splitAtOp ns op))

-- assumes that tree is cnf <-> tree is nnf and does not contain 'and' nodes with 
-- 'or' children
isCNF :: MTree -> Bool 
isCNF (Leaf l)      = True 
isCNF (Node And ns) = foldl (\x y -> x && (not $ isDisjunction y) && isCNF y) True ns 
isCNF (Node _ ns)   = foldl (\x y -> x && isCNF y) True ns

isDisjunction :: MTree -> Bool 
isDisjunction (Node Or _) = True 
isDisjunction _           = False

isConjunction :: MTree -> Bool
isConjunction (Node And _) = True 
isConjunction _            = False

{-
    Tree Transforming Functions
-}

negate :: MTree -> MTree 
negate n@(Leaf _)                   = Node Negate [n]
negate (Node Negate [n@(Leaf _)])   = n 
negate (Node Negate [n@(Node _ _)]) = n
negate n@(Node _ _)                 = Node Negate [n] 
 
resolveEquivalence :: MTree -> MTree 
resolveEquivalence n@(Leaf _)      = n 
resolveEquivalence (Node Equiv ns) = let impl1 = Node Impl [head ns, tail ns]
                                         impl2 = Node Impl [tail ns, head ns]
                                         impl1 = resolveEquivalence impl1 
                                         impl2 = resolveEquivalence impl2
                                     in  Node And [impl1, impl2] 
resolveEquivalence (Node op ns)    = Node op $ map equivalences ns

resolveImplication :: MTree -> MTree 
resolveImplication n@(Leaf _)     = n 
resolveImplication (Node Impl ns) = Node Or $ f [] ns where 
                                        f xs []     = xs
                                        f xs (y:ys) = f (map negate $ y:xs) ys 
resolveImplication (Node op ns)   = Node op $ map resolveImplication ns 

-- assumes argument does not contain equivalences & implications
resolveNegation :: MTree -> MTree 
resolveNegation (Node Negate [(Node And ns)])     = Node Or $ map (resolveNegation . negate) ns
resolveNegation (Node Negate [(Node Or ns)])      = Node And $ map (resolveNegation . negate) ns 
resolveNegation (Node Negate [(Node Negate [n])]) = n 
resolveNegation n                                 = n 
   
-- assumes argument is in negation normal form
distributiveOr :: MTree -> MTree
distributiveOr n@(Leaf _)      = n
distributiveOr n@(Node And ns) = 
    if not $ and $ map (flip hasOperator And) ns 
        then let (Node And ns) = associativity n
                 disjunction   = head $ fst $ splitAtOp ns Or 
                 rest          = snd $ splitAtOp ns Or
                 toConjunct1   = head $ children disjunction
                 toConjunct2   = tail $ children disjunction
                 conjunction1  = Node And $ rest ++ [toConjunct1]
                 conjunction2  = Node And $ rest ++ toConjunct2
             in Node Or [conjunction1, conjunction2]
    else Node And $ map distributiveOr ns
distributiveOr (Node op ns)     = Node op $ map distributiveOr ns

-- assumes argument is in negation normal form
distributiveAnd :: MTree -> MTree 
distributiveAnd n@(Leaf _)     = n
distributiveAnd n@(Node Or ns) = 
    if not $ or $ map (flip hasOperator Or) ns 
        then let (Node Or ns)  = associativity n
                 conjunction   = head $ fst $ splitAtOp ns And 
                 rest          = snd $ splitAtOp ns And
                 toDisjunct1   = head $ children conjunction
                 toDisjunct2   = tail $ children conjunction
                 disjunction1  = Node Or $ rest ++ [toDisjunct1]
                 disjunction2  = Node Or $ rest ++ toDisjunct2
             in Node Or [disjunction1, disjunction2]
    else Node Or $ map distributiveAnd ns
distributiveAnd (Node op ns)   = Node op $ map distributiveAnd ns

-- resolves redundant brackets
associativity :: MTree -> MTree 
associativity n@(Leaf _)       = n 
associativity (Node op (n:ns)) = 
    if hasOperator n op 
        then associativity (Node op $ ns ++ (children n))
    else Node op $ n:(map associativity ns)
